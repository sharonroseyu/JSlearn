# 性能优化篇-笔记整理
> 参考尚硅谷-B站视频教程
## 1. 浏览器功能与组成
 在浏览器中总有一个重要的模块
- safari -- webkit
- chrome webkit Blink
- Opera -- pewsto
- forefox -- Gecko
- Ie浏览器 -- Trident
> JS引擎是单线程运行的，进程可以通过任务管理器查看，线程看不到。
浏览器进程
1. 浏览器的主进程，负责浏览器界面的显示，和各个页面的管理，浏览器中所有其他类型进程的祖先，负责其他进程的创建和销毁，它有且只有一个
2. render进程，网页渲染过程，负责页面的渲染，可以由多个，当然渲染进程的数量不一定的与你开网页的个数
3. 各种插件进程
4. GPU进程，移动设备的浏览器可能不太一样，android不支持插件，所以没有插件进程，gpu演化成了browser进程的一个线程，render进程演化成了操作系统的一个服务进程，它仍然是独立的。在render进程中，为了不让其他操作组织渲染现成的高速执行，我们通常会将渲染过程【管线化】，利于计算机多核优化，让渲染的不同阶段在不同的线程中执行。

> 每个进程内部又有多个线程，主要目的是保持用户界面的高度响应

### 浏览器渲染引擎
#### 主要模块
> 一个渲染引擎主要包裹：html解析器 css解析器 javascript解析器 布局layout解析器 绘图模块
1. html 解析器: 解释html文档的解析器，只要时间html文本解释成dom树。
2. css解析器： 它的作用是为都没中的各个元素对象计算出样式信息，为布局提供基础设施。
3. javascript引擎：使用javascript代码可以修改网页内容，能够修改css信息，jsyixing可以解释js代码，并通过dom接口h和css树接口来修改网页内容和样式信息，从而
4. 布局(layout)：在dom创建之后，webkitt需要将其中的元素对象同样式结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型。
5. 绘图模块(paint): 使用图形库将布局计算后的各个网页的节点绘制成图像结果。

#### 渲染过程
> 浏览器熏染页面的整个过程，浏览器会从上到下解析文档
1. 遇见html标价，调用html解析器为对应的token(一个token就是一个标签文本的序列化)并侯建dom树（就是一块内存，保存tokens,建立他们之间的关系)
2. 遇见style/link标记，调用解析器处理css标记并构建css样式树。
3. 遇见script，调用javascript解析器，处理script标记，绑定事件，修改dom/css树等
4. 将dom树和css树，合并成一个渲染树。
5. 根据渲染树来渲染，一计算每个节点的结合信息(这一过程需要依赖图形库)
6. 将各个节点绘制到屏幕上。
> 以上这些模块依赖其它很多的基础模块，包括使用到网络 存储 2D/3D图像 音频视频解码器和图片解码器
> 所以渲染引擎中海惠包括如何使用这些依赖模块的部分

#### 阻塞渲染
1. css阻塞  只有link引入的外部css才能产生阻塞
    - style标签中的样式
        1. 由html解析器进行解析
        2. 不足赛浏览器渲染（可能会出现闪频现象）
        3. 不阻塞dom解析
    - link 引入的外部css样式（推荐使用方式）   
        1. 由css解析器进行解析
        2. 阻塞浏览器渲染（可以利用这种阻塞避免闪频现象）
        3. 阻塞其后面的js语句执行
            - 原因：如果后面的js的内容是获取元素样式，开入狂傲等css控制的属性，如果不等样式解析完毕，后面的js就获得了错误信息。
            - 注意：现代浏览器注重用户体验，对于webkit内核而言，仅当脚本尝试性访问的样式属性，或可能受尚未加载的样式表影响时，他才会禁止该脚本。
        4. 不阻塞dom解析
            - 原因：dom解析和css解析是两个并行的进程，浏览器解析dom生成domTree，解析css生成csstree，最终组成rendertree，再渲染页面
2. 优化的核心理念：尽可能句爱的提高外部css加载速度

### 浏览器渲染原理



### 优化方案
> 如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的工作(尽量减少1234步)
 - 1. 计算需要被加载到节点上的样式结果（Recalculate style -- 样式重计算）
 - 2. 为每个节点生成图形和位置（Layout -- 回流和重布局）
 - 3. 将每个节点填充到图层中（Paint Setup 和 Paint -- 重绘）
 - 4. 组合图层到页面上（Composite Layers -- 图层重组）

> 具体优化方面：
+ 1. 元素位置移动变幻时尽量视同css3的transform来代替top left 等的操作，变换（transform）和透明度（opacity）的改变仅影响涂图层的组合。
+ 2. 使用opacity来代替visibility,
  - 1). 使用visibility不出发重拍，但是依然重绘。
  - 2). 直接使用opacity即触发重绘，又出发重拍（GPU底层设计如此）
  - 3). opacity配合图层使用，即不会出发重绘也不触发重排。【transform:translateZ(0)/will-】
    * 原因: 透明度改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值达到效果，并不需要整体的重绘，不过这个前提是这个被修改opacity本身必须是一个图层。
+ 3. 不要使用table布局 table-cell。
+ 4. 将多次改变样式属性的操作合并成一次操作，不要一条一条的修改dom样式，预先定义好class，然后修改dom的className。
+ 5. 将DOM离线后在修改，由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排，如果要对一个元素进行复杂的操作时，可以先隐藏他，操作完成后再显示。这样只在隐藏和显示时触发两次
+ 6. 利用文档碎片（documentFragment） -- vue 使用了这种方式提升性能。
+ 7. 不要把获取某些dom节点的属性值放在一个循环里当成局部变量，当你请求向浏览器请求一些style信息的时候，就会让浏览器flush队列，比如：
  - 1. offsetTop，offsetLeft, offsetWidth,offsetHieght
  - 2. scrollTop/Left/Widt/Height
  - 3. clientTop/Left/Width/Height
  - 4. width,height
  > 当你请求上面一些属性的时候，浏览器为了给你最精确的值，需要舒刷新内部队列，因为队列中可能会影响到这些值的操作，即使你获取元素的布局和样式信息跟最近发生改变的布局信息。浏览器会强行舒心渲染队列.
+ 8. 动画实现过程中，开启GPU硬件加速：transform：translateZ(0);
+ 9. 为动画元素新建图层，提高动画元素的z-index